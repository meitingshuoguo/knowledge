# 事件委托
捕获和冒泡允许我们实现最强大的事件处理模式之一，即 **事件委托** 模式。

如果我们有许多以类似方式处理的元素，那么就不必为每个元素分配一个处理程序 —— 而是将单个处理程序放在它们的共同祖先上。

在处理程序中，我们获取 `event.target` 以查看事件实际发生的位置并进行处理。

算法：

1.  在容器（container）上放一个处理程序。
2.  在处理程序中 —— 检查源元素 `event.target`。
3.  如果事件发生在我们感兴趣的元素内，那么处理该事件。


好处：

-   简化初始化并节省内存：无需添加许多处理程序。
-   更少的代码：添加或移除元素时，无需添加/移除处理程序。
-   DOM 修改 ：我们可以使用 `innerHTML` 等，来批量添加/移除元素。

局限性：

-   首先，事件必须冒泡。而有些事件不会冒泡。此外，低级别的处理程序不应该使用 `event.stopPropagation()`。
-   其次，委托可能会增加 CPU 负载，因为容器级别的处理程序会对容器中任意位置的事件做出反应，而不管我们是否对该事件感兴趣。但是，通常负载可以忽略不计，所以我们不考虑它。