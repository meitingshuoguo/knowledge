# what：

1. 没有 `this`
	1. 它会捕获自己在**定义时**（注意，是定义时，不是调用时）所处的**外层执行环境的`this`**，并继承这个`this`值。所以，箭头函数中`this`的指向在它被定义的时候就已经确定了，之后永远不会改变。
	2. `.call()`/`.apply()`/`.bind()`方法可以用来动态修改函数执行时`this`的指向，但由于箭头函数的`this`定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭
2. 没有 `arguments`, `caller`, `prototype`
	1. 普通函数`outer`内部的箭头函数`fun`中的`arguments`对象，其实是沿作用域链向上访问的外层`outer`函数的`arguments`对象。
3. 不能使用 `new` 进行调用
	构造函数的new都做了些什么？简单来说，分为四步：
	1. JS内部首先会先生成一个对象；
	2. 再把函数中的this指向该对象；
	3. 然后执行构造函数中的语句；
	4. 最终返回该对象实例。
	但是！！因为箭头函数没有自己的`this`，它的`this`其实是继承了外层执行环境中的`this`，且`this`指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用`new`调用时会报错！
4. 它们也没有 `super`，但目前我们还没有学到它。我们将在 [类继承](https://zh.javascript.info/class-inheritance) 一章中学习它。


# 使用场景
1.  箭头函数适合于无复杂逻辑或者无副作用的纯函数场景下，例如用在`map`、`reduce`、`filter`的回调函数定义中；
2.  不要在最外层定义箭头函数，因为在函数内部操作`this`会很容易污染全局作用域。最起码在箭头函数外部包一层普通函数，将`this`控制在可见的范围内；
3.  如开头所述，箭头函数最吸引人的地方是简洁。在有多层函数嵌套的情况下，箭头函数的简洁性并没有很大的提升，反而影响了函数的作用范围的识别度，这种情况不建议使用箭头函数。